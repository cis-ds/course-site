---
title: "Statistical learning: resampling methods"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

# Objectives

* Define resampling methods
* Compare and contrast the validation set approach with leave-one-out and $k$-fold cross-validation
* Define bootstrapping and explain when it can be used in research
* Demonstrate how to conduct cross-validation and bootstrapping using `modelr`

```{r packages, message = FALSE, warning = FALSE, cache = FALSE}
library(tidyverse)
library(modelr)
library(broom)
options(na.action = na.warn)
set.seed(1234)

theme_set(theme_bw())
```

# Resampling methods

Resampling methods are essential to test and evaluate statistical models. Because you likely do not have the resources or capabilities to repeatedly sample from your population of interest, instead you can repeatedly draw from your original sample to obtain additional information about your model. For instance, you could repeatedly draw samples from your data, estimate a linear regression model on each sample, and then examine how the estimated model differs across each sample. This allows you to assess the variability and stability of your model in a way not possible if you can only fit the model once.

# Validation set

We have already seen the **validation set** approach in the [previous class](stat003_logistic_regression.html). By splitting our data into a **training set** and **test set**, we can evaluate the model's effectiveness at predicting the response variable (in the context of either regression or classification) independently of the data used to estimate the model in the first place.

## Classification

Recall how we used this approach to evaluate the accuracy of our [interactive model predicting survival during the sinking of the Titanic](stat003_logistic_regression.html#interactive_terms).

```{r titanic_data, message = FALSE}
library(titanic)
titanic <- titanic_train %>%
  as_tibble()

titanic %>%
  head() %>%
  knitr::kable()
```

```{r age_woman_cross}
survive_age_woman_x <- glm(Survived ~ Age * Sex, data = titanic,
                           family = binomial)
summary(survive_age_woman_x)
```

```{r logit}
logit2prob <- function(x){
  exp(x) / (1 + exp(x))
}
```

```{r accuracy_age_gender_x_test_set, dependson="age_woman_cross", message = FALSE}
library(modelr)

titanic_split <- resample_partition(titanic, c(test = 0.3, train = 0.7))
map(titanic_split, dim)

train_model <- glm(Survived ~ Age + Sex, data = titanic_split$train,
                   family = binomial)
summary(train_model)

x_test_accuracy <- titanic_split$test %>%
  tbl_df() %>%
  add_predictions(train_model) %>%
  mutate(pred = logit2prob(pred),
         pred = as.numeric(pred > .5))

mean(x_test_accuracy$Survived == x_test_accuracy$pred, na.rm = TRUE)
```

## Regression

This method also works for regression analysis. Here we will examine the relationship between horsepower and car mileage in the `Auto` dataset (found in `library(ISLR)`):

```{r auto}
library(ISLR)

Auto <- Auto %>%
  tbl_df()
Auto
```

```{r auto_plot, dependson="auto"}
ggplot(Auto, aes(horsepower, mpg)) +
  geom_point()
```

The relationship does not appear to be strictly linear:

```{r auto_plot_lm, dependson="auto"}
ggplot(Auto, aes(horsepower, mpg)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```

Perhaps by adding [quadratic terms](stat003_logistic_regression.html#quadratic_terms) to the linear regression we could improve overall model fit. To evaluate the model, we will split the data into a training set and test set, estimate a series of higher-order models, and calculate a test statistic summarizing the accuracy of the estimated `mpg`. Rather than relying on the raw error rate (which makes sense in a classification model), we will instead use **Mean Squared Error** ($MSE$), defined as

$$MSE = \frac{1}{n} \sum_{i = 1}^{n}{(y_i - \hat{f}(x_i))^2}$$

where:

* $y_i =$ the observed response value for the $i$th observation
* $\hat{f}(x_i) =$ the predicted response value for the $i$th observation given by $\hat{f}$
* $n =$ the total number of observations

Boo math! Actually this is pretty intuitive. All we're doing is for each observation, calculating the difference between the actual and predicted values for $y$, squaring that difference, then calculating the average across all observations. An $MSE$ of 0 indicates the model perfectly predicted each observation. The larger the $MSE$, the more error in the model.

For this task, first we can use `modelr::resample_partition()` to create training and test sets (using a 50/50 split), then estimate a linear regression model without any quadratic terms.

* I use `set.seed()` in the beginning - whenever you are writing a script that involves randomization (here, random subsetting of the data), always set the seed at the beginning of the script. This ensures the results can be reproduced precisely.^[The actual value you use is irrelevant. Just be sure to set it in the script, otherwise R will randomly pick one each time you start a new session.]
* I also use the `glm()` function rather than `lm()` - if you don't change the `family` parameter, the results of `lm()` and `glm()` are exactly the same.^[The default `family` for `glm()` is `gaussian()`, or the **Gaussian** distribution. You probably know it by its other name, the [**Normal** distribution](https://en.wikipedia.org/wiki/Normal_distribution).]

```{r auto_split}
set.seed(1234)

auto_split <- resample_partition(Auto, c(test = 0.5, train = 0.5))
auto_train <- auto_split$train %>%
  tbl_df()
auto_test <- auto_split$test %>%
  tbl_df()
```

```{r auto_lm, dependson="auto_split"}
auto_lm <- glm(mpg ~ horsepower, data = auto_train)
summary(auto_lm)
```

To estimate the $MSE$ for a single partition (i.e. for a training or test set), I wrote a special function `mse()`:^[This function can also be loaded via the [`rcfss`](https://github.com/uc-cfss/rcfss) library. Be sure to update your package to the latest version to make sure the function is available.]

```{r mse-function}
mse <- function(model, data) {
  x <- modelr:::residuals(model, data)
  mean(x ^ 2, na.rm = TRUE)
}
```

```{r mse, dependson="auto_split"}
mse(auto_lm, auto_test)
```

For a strictly linear model, the $MSE$ for the test set is `r formatC(mse(auto_lm, auto_test), digits = 4)`. How does this compare to a quadratic model? We can use the `poly()` function in conjunction with a `map()` iteration to estimate the $MSE$ for a series of models with higher-order polynomial terms:

```{r mse_poly, dependson="auto_split"}
auto_poly_results <- data_frame(terms = 1:5,
           model = map(terms, ~ glm(mpg ~ poly(horsepower, .), data = auto_train)),
           MSE = map_dbl(model, mse, data = auto_test))

ggplot(auto_poly_results, aes(terms, MSE)) +
  geom_line() +
  labs(title = "Comparing quadratic linear models",
       subtitle = "Using validation set",
       x = "Highest-order polynomial",
       y = "Mean Squared Error")
```

Based on the $MSE$ for the validation (test) set, a polynomial model with a quadratic term ($\text{horsepower}^2$) produces the lowest average error. Adding cubic or higher-order terms is just not necessary.

## Drawbacks to validation sets

There are two main problems with validation sets:

1. Validation estimates of the test error rates can be highly variable depending on which observations are sampled into the training and test sets. See what happens if we repeat the sampling, estimation, and validation procedure for the `Auto` data set:

    ```{r auto_variable_mse}
mse_variable <- function(Auto){
  auto_split <- resample_partition(Auto, c(test = 0.5, train = 0.5))
  auto_train <- auto_split$train %>%
    tbl_df()
  auto_test <- auto_split$test %>%
    tbl_df()
  
  results <- data_frame(terms = 1:5,
                        model = map(terms, ~ glm(mpg ~ poly(horsepower, .), data = auto_train)),
                        MSE = map_dbl(model, mse, data = auto_test))
  
  return(results)
}

rerun(10, mse_variable(Auto)) %>%
  bind_rows(.id = "id") %>%
  ggplot(aes(terms, MSE, color = id)) +
  geom_line() +
  labs(title = "Variability of MSE estimates",
       subtitle = "Using the validation set approach",
       x = "Degree of Polynomial",
       y = "Mean Squared Error") +
  theme(legend.position = "none")
    ```

1. If you don't have a large data set, you'll have to dramatically shrink the size of your training set. Most statistical learning methods perform better with more observations - if you don't have enough data in the training set, you might overestimate the error rate in the test set.

# Leave-one-out cross-validation

An alternative method is **leave-one-out cross validation** (LOOCV). Like with the validation set approach, you split the data into two parts. However the difference is that you only remove one observation for the test set, and keep all remaining observations in the training set. The statistical learning method is fit on the $n-1$ training set. You then use the held-out observation to calculate the $MSE = (y_1 - \hat{y}_1)^2$ which should be an unbiased estimator of the test error. Because this $MSE$ is highly dependent on which observation is held out, **we repeat this process for every single observation in the data set**. Mathematically, this looks like:

$$CV_{(n)} = \frac{1}{n} \sum_{i = 1}^{n}{MSE_i}$$

This method produces estimates of the error rate that have minimal bias and are relatively steady (i.e. non-varying), unlike the validation set approach where the $MSE$ estimate is highly dependent on the sampling process for training/test sets. LOOCV is also highly flexible and works with any kind of predictive modeling.

Of course the downside is that this method is computationally difficult. You have to estimate $n$ different models - if you have a large $n$ or each individual model takes a long time to compute, you may be stuck waiting a long time for the computer to finish its calculations.

## LOOCV in linear regression

We can use the `crossv_kfold()` function in the `modelr` library to compute the LOOCV of any linear or logistic regression model. It takes two arguments: the data frame and the number of $k$-folds (which we will define shortly). For our purposes, all you need to know is that `k` should equal the number of observations in the data frame which we can retrieve using the `nrow()` function. For the `Auto` dataset, this looks like:

```{r loocv-data, dependson="Auto"}
loocv_data <- crossv_kfold(Auto, k = nrow(Auto))
```

Now we estimate the linear model $k$ times, excluding the holdout test observation, then calculate the $MSE$:

```{r loocv, dependson="Auto"}
loocv_models <- map(loocv_data$train, ~ lm(mpg ~ horsepower, data = .))
loocv_mse <- map2_dbl(loocv_models, loocv_data$test, mse)
mean(loocv_mse)
```

The results of the mapped `mse()` function is the $MSE$ for each iteration through the data, so there is one $MSE$ for each observation. Calculating the `mean()` of that vector gives us the LOOCV $MSE$.

We can also use this method to compare the optimal number of polynomial terms as before.

```{r loocv_poly, dependson="Auto"}
cv_error <- vector("numeric", 5)
terms <- 1:5

for(i in terms){
  loocv_models <- map(loocv_data$train, ~ lm(mpg ~ poly(horsepower, i), data = .))
  loocv_mse <- map2_dbl(loocv_models, loocv_data$test, mse)
  cv_error[[i]] <- mean(loocv_mse)
}

cv_mse <- data_frame(terms = terms,
           cv_MSE = cv_error)
cv_mse

ggplot(cv_mse, aes(terms, cv_MSE)) +
  geom_line() +
  labs(title = "Comparing quadratic linear models",
       subtitle = "Using LOOCV",
       x = "Highest-order polynomial",
       y = "Mean Squared Error")
```

And arrive at a similar conclusion. There may be a very marginal advantage to adding a fifth-order polynomial, but not substantial enough for the additional complexity over a mere second-order polynomial.

## LOOCV in classification

Let's use classification to validate the interactive terms model from before. For technical reasons, we need to use a custom `mse.glm()` function to properly calculate the $MSE$ for binary response variables:^[This function can also be loaded via the [`rcfss`](https://github.com/uc-cfss/rcfss) library. Be sure to update your package to the latest version to make sure the function is available.]

```{r mse-glm}
mse.glm <- function (model, data){
  residuals.glm <- function(model, data) {
    modelr:::response(model, data) - stats::predict(model, data, type = "response")
  }
  
  x <- residuals(model, data)
  mean(x^2, na.rm = TRUE)
}
```

```{r titanic_loocv}
titanic_loocv <- crossv_kfold(titanic, k = nrow(titanic))
titanic_models <- map(titanic_loocv$train, ~ glm(Survived ~ Age * Sex, data = .,
                                               family = binomial))
titanic_mse <- map2_dbl(titanic_models, titanic_loocv$test, mse.glm)
mean(titanic_mse, na.rm = TRUE)
```

In a classification problem, the LOOCV tells us the average error rate based on our predictions. So here, it tells us that the interactive `Age * Sex` model has a `r formatC(titanic_loocv$delta[[1]] * 100, digits = 3)`% error rate. This is similar to the validation set result ($`r formatC(mean(x_test_accuracy$Survived == x_test_accuracy$pred, na.rm = TRUE) * 100, digits = 3)`\%$)

# k-fold cross-validation

A less computationally-intensive approach to cross validation is $k$-fold cross-validation. Rather than dividing the data into $n$ groups, one divides the observations into $k$ groups, or **folds**, of approximately equal size. The first fold is treated as the validation set, and the model is estimated on the remaining $k-1$ folds. This process is repeated $k$ times, with each fold serving as the validation set precisely once. The $k$-fold CV estimate is calculated by averaging the $MSE$ values for each fold:

$$CV_{(k)} = \frac{1}{k} \sum_{i = 1}^{k}{MSE_i}$$

As you probably figured out by now, LOOCV is the special case of $k$-fold cross-validation where $k = n$. More typically researchers will use $k=5$ or $k=10$ depending on the size of the data set and the complexity of the statistical model.

## k-fold CV in linear regression

Let's go back to the `Auto` data set. Instead of LOOCV, let's use 10-fold CV to compare the different polynomial models.

```{r 10_fold_auto}
cv10_data <- crossv_kfold(Auto, k = 10)

cv_error_fold10 <- vector("numeric", 5)
terms <- 1:5

for(i in terms){
  cv10_models <- map(cv10_data$train, ~ lm(mpg ~ poly(horsepower, i), data = .))
  cv10_mse <- map2_dbl(cv10_models, cv10_data$test, mse)
  cv_error_fold10[[i]] <- mean(cv10_mse)
}

cv_error_fold10
```

How do these results compare to the LOOCV values?

```{r 10_fold_auto_loocv, dependson=c("10_fold_auto","loocv_poly")}
data_frame(terms = terms,
           loocv = cv_error,
           fold10 = cv_error_fold10) %>%
  gather(method, MSE, loocv:fold10) %>%
  ggplot(aes(terms, MSE, color = method)) +
  geom_line() +
  labs(title = "MSE estimates",
       x = "Degree of Polynomial",
       y = "Mean Squared Error",
       color = "CV Method")
```

Pretty much the same results.

## Computational speed of LOOCV vs. $k$-fold CV

### LOOCV

```{r loocv_time}
library(profvis)

profvis({
  cv_error <- vector("numeric", 5)
  terms <- 1:5
  
  for(i in terms){
    loocv_models <- map(loocv_data$train, ~ lm(mpg ~ poly(horsepower, i), data = .))
    loocv_mse <- map2_dbl(loocv_models, loocv_data$test, mse)
    cv_error[[i]] <- mean(loocv_mse)
  }
})
```

### 10-fold CV

```{r kfold_time}
library(profvis)

profvis({
  cv_error_fold10 <- vector("numeric", 5)
  terms <- 1:5
  
  for(i in terms){
    cv10_models <- map(cv10_data$train, ~ lm(mpg ~ poly(horsepower, i), data = .))
    cv10_mse <- map2_dbl(cv10_models, cv10_data$test, mse)
    cv_error_fold10[[i]] <- mean(cv10_mse)
  }
})
```

On my machine, 10-fold CV was about 40 times faster than LOOCV. Again, estimating $k=10$ models is going to be much easier than estimating $k=`r nrow(Auto)`$ models.

## k-fold CV in logistic regression

You've gotten the idea by now, but let's do it one more time on our interactive Titanic model.

```{r titanic_kfold}
titanic_kfold <- crossv_kfold(titanic, k = 10)
titanic_models <- map(titanic_kfold$train, ~ glm(Survived ~ Age * Sex, data = .,
                                               family = binomial))
titanic_mse <- map2_dbl(titanic_models, titanic_kfold$test, mse.glm)
mean(titanic_mse, na.rm = TRUE)
```

Not a large difference from the LOOCV approach, but it take much less time to compute.

# Session Info {.toc-ignore}

```{r child='_sessioninfo.Rmd'}
```






